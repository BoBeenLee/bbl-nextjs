{"pageProps":{"slug":"react-facc-hoc","frontmatter":{"path":"/post/react-facc-hoc","title":"Function as Child Component And High Order Component","published":true,"date":"2018-03-08"},"content":"<p>HOC는 많은 사람들이 이미 알고 있고 자주 사용하기에 따로 설명은 하지 않겠다. \n<a href=\"https://reactjs.org/docs/higher-order-components.html\">공식문서</a>에도 자세히 설명 되어있다. \n주로 보통 HOC는 공통 기능, 횡단 관심사 분리 위해서 사용해왔었다. \nex) loading, auth, logging, tracking 등등...</p>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a>의 예시를 참조하여 구현해보자.</p>\n<h2>High Order Component</h2>\n<pre><code>function withMouse(Component) {\n  return class extends React.Component {\n    constructor(props) {\n      super(props);\n      this.handleMouseMove = this.handleMouseMove.bind(this);\n      this.state = { x: 0, y: 0 };\n    }\n\n    handleMouseMove(event) {\n      this.setState({\n        x: event.clientX,\n        y: event.clientY\n      });\n    }\n\n    render() {\n      return (\n        &#x3C;div style={{ height: \"100%\" }} onMouseMove={this.handleMouseMove}>\n          &#x3C;Component {...this.props} mouse={this.state} />\n        &#x3C;/div>\n      );\n    }\n  };\n}\n</code></pre>\n<p>만일 <a href=\"https://github.com/mridgway/hoist-non-react-statics\">Static Methods</a>를 카피하기 위해선 별도의 로직도 필요할 것이다.</p>\n<h3>Problem</h3>\n<ol>\n<li>Duplication Props \nMouse, Touch기능을 같이 사용하고 싶다면\n<pre><code>withMouse(withTouch(class extends React.Component { ... }));\nor\n@mouse\n@touch\nclass Component extends React.Component { ... }\n</code></pre>\n로 구현할텐데\n만일 withTouch와 withMouse 둘다 동일한 mouse props를 넘겨줄 경우, withMouse의 mouse props는 원하는 데로 동작을 안할 것이다.</li>\n<li>여러개의 HOC를 사용할 경우 props의 복잡도 증가\n<pre><code>compose(withMouse, withTouch, withUser, withAuth, withLoading)(...)\nor\n@mouse\n@touch\n@user\n@auth\n@loading\n...\n</code></pre>\n여러개의 HOC를 사용할 경우, 어떤 props가 어떤 HOC에서 넘어왔는지 명시적이지 않아 직접 구현체 HOC props를 확인해야하는 경우가 생기게 된다.</li>\n</ol>\n<h3>Solution</h3>\n<p>Function as Child Component으로 1, 2의 이슈를 해결할 수 있다.</p>\n<h2>Function as Child Component</h2>\n<pre><code>class Mouse extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.state = { x: 0, y: 0 };\n  }\n\n  handleMouseMove(event) {\n    this.setState({\n      x: event.clientX,\n      y: event.clientY\n    });\n  }\n\n  render() {\n    return (\n      &#x3C;div style={{ height: \"100%\" }} onMouseMove={this.handleMouseMove}>\n        {this.props.children(this.state)}\n      &#x3C;/div>\n    );\n  }\n}\n</code></pre>\n<pre><code> // touch, mouse implementation code ...\n render() {\n    return (&#x3C;Touch>\n    {this.renderTouch}\n    &#x3C;/Touch>);\n }\n\n renderTouch = (touch) => (&#x3C;Mouse>\n    { (mouse) => &#x3C;Cat mouse={mouse} touch={touch} /> }\n    &#x3C;/Mouse>);\n</code></pre>\n<p>위와 같이 Touch FaCC를 renderTouch arrow function으로 작성하고\nMouse는 arrow function을 직접 내부에 구현하였다. \n둘의 차이점은 Touch, Mouse컴포넌트 둘다 PureComponent일 경우, \nMouse컴포넌트는 랜더링 될때마다 함수를 매번 생성하여 전달해줄 것이고\nrenderTouch는 한번만 호출되어 랜더링 될 것이다. \n<a href=\"https://reactjs.org/docs/render-props.html#be-careful-when-using-render-props-with-reactpurecomponent\">PureComponent - Shallow Comparison</a> \n위의 구현으로 HOC의 1,2번 문제가 해결될 수 있음을 확인할 수 있다.</p>\n<ul>\n<li>props를 직접 전달 받지 않기에 속성이 겹치는 문제가 발생하지 않는다.</li>\n<li>props, state, context을 function로 명시적으로 받아 처리하기에 어떤 속성이 어느 컴포넌트에서 넘어왔는지 알기 쉽다.</li>\n<li>FaCC로 HOC구현도 쉽게 가능하다.\n<pre><code>function withMouse(Component) {\n  return class extends React.Component {\n    render() {\n      return (\n        &#x3C;Mouse>{mouse => &#x3C;Component {...this.props} mouse={mouse} />}&#x3C;/Mouse>\n      );\n    }\n  };\n}\n</code></pre>\n</li>\n</ul>\n<p>그리고 직접적으로 말은 안했지만 Render Prop와 FaCC는 동일한 개념이고 child이냐 render props이냐 차이일뿐 동일하다.</p>\n<h3>Problem</h3>\n<p><a href=\"https://reactjs.org/docs/render-props.html#caveats\">Render Props Caveats</a> 예시와 동일하게 Mouse에 PureComponent로 했을 경우, \nMouseTracker가 counter를 증가하는 랜더링을 하면 자식 Cat컴포넌트는 다시 랜더링하지 않는다. \n그 이유는 Mouse컴포넌트가 render props으로 bind된 항상 같은 함수를 받아 Mouse 컴포넌트는 랜더링되지 않는다. \n그래서 counter숫자가 증가되지 않는다.</p>\n<p><a href=\"https://codesandbox.io/s/ll2xq45x3q\"><img src=\"https://codesandbox.io/static/img/play-codesandbox.svg\" alt=\"Edit ll2xq45x3q\"></a></p>\n<p>결국 Render Props나 FaCC를 사용함으로 shouldComponentUpdate로 optimize하기 어려워지는 이슈가 있다.\n(render or child로 함수를 넘겨주고 shouldComponentUpdate로 비교하기에)</p>\n<h2>Conclusion</h2>\n<p>HOC가 만능이 아닌 것처럼 FaCC, HOC를 사용할때 위와 같은 이슈들을 유념하면서 사용하자.\n그리고 기존에 존재하는 라이브러리를 한번 참조해보고 사용해보는 것이 좋을거같다.\nHOC - <a href=\"https://github.com/reactjs/react-redux\">React Redux(connect)</a>, <a href=\"https://github.com/ReactTraining/react-router\">React Router(withRouter)</a>, <a href=\"https://github.com/apollographql/react-apollo\">Apollo(graphql)</a> \nFaCC, Render Props - <a href=\"https://github.com/chenglou/react-motion\">React Motion</a>, <a href=\"https://github.com/apollographql/react-apollo\">React Apollo(Query tag)</a>, <a href=\"https://github.com/FormidableLabs/urql\">urql(Query tag)</a>, <a href=\"https://github.com/ReactTraining/react-router\">React Router(render props)</a></p>\n<h2>Reference</h2>\n<p><a href=\"https://reactjs.org/docs/render-props.html\">Render Props</a> \n<a href=\"https://www.youtube.com/watch?v=BcVAq3YFiuc&#x26;index=2&#x26;list=PLXB3WIVcnsH1TZxTuF6YaiRV0eVWAJhfC&#x26;t=613s\">Michael Jackson - Never Write Another HoC</a></p>\n"},"__N_SSG":true}